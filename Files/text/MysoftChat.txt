[19:44] <+Mysoft> well it would work as well
[19:44] <+Mysoft> but i think having a main file dedicated
[19:45] <+Mysoft> works very nicely
[19:45] <+Mysoft> and its 100% compatible with compiling as modules
[19:45] <qwebirc23602> yeah thats what ill do
[19:45] <+Mysoft> so if your projects gets bigger
[19:45] <+Mysoft> you are already ready to it :P
[19:45] <+Mysoft> and btw...
[19:45] <+Mysoft> i bet if you do it later...
[19:45] <+Mysoft> when you change to modules
[19:45] <+Mysoft> you may end NOTICING the speed difference
[19:45] <+Mysoft> (as long you are compiling with -gen gcc that is)
[19:45] <+Mysoft> :P
[19:49] <qwebirc23602> slower speed right
[19:49] <qwebirc23602> why would I want to use modules
[19:49] <qwebirc23602> if I can just include it all in the header?
[19:54] <+Mysoft> well
[19:55] <+Mysoft> later if your project get bigger
[19:55] <+Mysoft> say >50k
[19:55] <+Mysoft> compiling may take "minutes"
[19:55] <qwebirc23602> so i should use modules
[19:55] <qwebirc23602> after a certain point
[19:55] <+Mysoft> yes if the compile time become a problem
[19:55] <+Mysoft> but
[19:55] <qwebirc23602> okay
[19:55] <+Mysoft> doing fbc *.bas -m
[19:55] <+Mysoft> wont solve that problem :P
[19:56] <qwebirc23602> but then you said gcc cant make things more efficient in the code
[19:56] <+Mysoft> yes
[19:56] <+Mysoft> you will have a tradeoff
[19:56] <qwebirc23602> so my final release should not be using modules
[19:56] <+Mysoft> yep :)
[19:56] <qwebirc23602> got it
[19:56] <+Mysoft> but as i'm saying
[19:56] <+Mysoft> doing fbc *.bas -m
[19:57] <+Mysoft> would not be faster to compile than the .h
[19:57] <+Mysoft> the speed up of using modules
[19:57] <+Mysoft> comes from ONLY recompiling the modules
[19:57] <+Mysoft> that actually changed
[19:57] <+Mysoft> so when you start actually needing modules you may need a compile file
[19:58] <+Mysoft> *make file
[19:58] <+Mysoft> to automatically detect what needs to be recompiled
[19:58] <+Mysoft> but really
[19:58] <+Mysoft> with the uber computers we have today
[19:58] <+Mysoft> you may never reach that point :P
[19:59] <+Mysoft> and if you want a hint
[19:59] <+Mysoft> dont ever use boolean
[20:00] <+Mysoft> as that forces you to use fbc 1.0.5
[20:00] <+Mysoft> for a feature that is not really useful
[20:00] <+Mysoft> since you should just use a integer
[20:00] <+Mysoft> instead of a boolean
[20:00] <+Mysoft> as what make something boolean is the check
[20:00] <+Mysoft> and you have all that is required on the checks anyway
[20:00] <+Mysoft> if x ...
[20:00] <+Mysoft> if x=0 ...
[20:00] <qwebirc23602> Mysoft
[20:00] <qwebirc23602> what should I do
[20:00] <+Mysoft> if not x ...
[20:00] <qwebirc23602> https://pastebin.com/Vgd548Vg
[20:00] <+Mysoft> is actually wrong :P
[20:01] <+Mysoft> because "not" is bitwise
[20:01] <+Mysoft> not logical
[20:01] <+Mysoft> yeah
[20:01] <+Mysoft> the macro for that
[20:01] <+Mysoft> is good
[20:01] <+Mysoft> but... i have a rule for consistency
[20:01] <+Mysoft> when using macros
[20:01] <+Mysoft> i keep the macros
[20:02] <+Mysoft> CLOSE
[20:02] <qwebirc23602> close to
[20:02] <+Mysoft> to where they are used
[20:02] <qwebirc23602> I see
[20:02] <+Mysoft> so you dont have to go
[20:02] <+Mysoft> back and forth
[20:02] <qwebirc23602> Well that goes against my organizing methods
[20:02] <+Mysoft> to know what the macro do
[20:02] <qwebirc23602> this would be stored in my .bas file for a .bi struct
[20:02] <qwebirc23602> my Dot struct
[20:02] <qwebirc23602> dot.bi
[20:02] <qwebirc23602> and dot.bas
[20:02] <+Mysoft> yeah i understand
[20:04] <qwebirc23602> https://pastebin.com/gEnJAWXx
[20:04] <qwebirc23602> how about this stuff
[20:04] <+Mysoft> but anyway
[20:04] <+Mysoft> in  your macro
[20:04] <qwebirc23602> this would be the constructor equivalent
[20:04] <+Mysoft> don't forget to use
[20:04] <+Mysoft> (x)
[20:05] <qwebirc23602> (x)?
[20:05] <+Mysoft> yes
[20:05] <qwebirc23602> for what
[20:05] <+Mysoft> consistency
[20:05] <qwebirc23602> ??
[20:05] <qwebirc23602> d->x = x
[20:05] <+Mysoft> remember what i said about math order
[20:05] <qwebirc23602> d->x = (x)
[20:05] <qwebirc23602> ?
[20:05] <+Mysoft> yes
[20:05] <+Mysoft> also
[20:05] <qwebirc23602> how does that make sense
[20:05] <+Mysoft> you noticed something there?
[20:05] <+Mysoft> x x
[20:05] <qwebirc23602> its the only thing
[20:05] <+Mysoft> this is not good in macros
[20:05] <+Mysoft> hence why
[20:05] <+Mysoft> i do
[20:06] <qwebirc23602> #MACRO dot_setPos(_d, _x, _y)
[20:06] <+Mysoft> yep
[20:06] <+Mysoft> thats why i do the _d _x _y
[20:06] <+Mysoft> to avoid name conflict
[20:06] <+Mysoft> so
[20:06] <+Mysoft> _d->x = (x)
[20:06] <+Mysoft> and for consistency i ALWAYS put parameters
[20:06] <+Mysoft> errr
[20:06] <+Mysoft> ALWAYS put parenthesis
[20:06] <+Mysoft> on the parameters from the macro
[20:07] <+Mysoft> even when they dont need
[20:07] <+Mysoft> in this case
[20:07] <+Mysoft> even on the _d
[20:07] <+Mysoft> it would be wise
[20:07] <+Mysoft> (_d)->x = (x)
[20:07] <qwebirc23602> so weird
[20:07] <+Mysoft> even if its clear that it will be fine without
[20:07] <qwebirc23602> would it be ok to use using _d
[20:07] <+Mysoft> it avoid several kinds of problems
[20:08] <qwebirc23602> or would i say using (_d)
[20:08] <+Mysoft> so for consistency i always use the parenthesis
[20:08] <+Mysoft> you dont need... but as you wish :)
[20:09] <+Mysoft> because macros are just "text replacement"
[20:09] <+Mysoft> so just like the ->x
[20:09] <+Mysoft> that you have not noticed
[20:09] <+Mysoft> there might be something
[20:09] <qwebirc23602> okay
[20:10] <+Mysoft> you may use that may end affecting
[20:10] <+Mysoft> even with just = x
[20:10] <+Mysoft> i can't think of any
[20:10] <+Mysoft> but with macros i dont take chances :)
[20:10] <qwebirc23602> Right ok
[20:10] <qwebirc23602> Ill make that my doctrine now
[20:10] <+Mysoft> you will see people saying that macros are evil
[20:10] <qwebirc23602> are they evil?
[20:10] <+Mysoft> so they would even recommend to never use them
[20:10] <+Mysoft> they can be pretty evil
[20:10] <qwebirc23602> got it
[20:10] <+Mysoft> just like a chainsaw in a kid hand
[20:10] <+Mysoft> :P
[20:10] <qwebirc23602> Is that what youve done to me?
[20:11] <qwebirc23602> Youve given me a chainsaw
[20:11] <qwebirc23602> and now im going to ruin my entire project :P
[20:11] <+Mysoft> xD
[20:11] <+Mysoft> well you are just doing mild macro usage :)
[20:11] <qwebirc23602> ok I have another macro question
[20:11] <+Mysoft> but you see
[20:11] <+Mysoft> even for the mild macro usage
[20:11] <+Mysoft> you ended doing the ->
[20:11] <+Mysoft> and ended doing the _d instead of (_d)
[20:12] <+Mysoft> also...
[20:12] <+Mysoft> heres another thing
[20:12] <+Mysoft> to pull your hair
[20:12] <+Mysoft> that you must REMEMBER
[20:12] <qwebirc23602> p_p
[20:12] <+Mysoft> -------
[20:12] <+Mysoft> #macro MyMacro()
[20:12] <+Mysoft>   print "Hello"
[20:12] <+Mysoft>   print "World"
[20:12] <+Mysoft> #endmacro
[20:13] <+Mysoft> if 0 then MyMacro()
[20:13] <+Mysoft> sleep
[20:13] <+Mysoft> --------
[20:13] <+Mysoft> run this code
[20:13] <qwebirc23602> I think I see it from here
[20:13] <qwebirc23602> itll print World
[20:13] <qwebirc23602> right?
[20:13] <+Mysoft> yes
[20:13] <qwebirc23602> so
[20:13] <qwebirc23602> that means
[20:13] <qwebirc23602> I cant do that kind of stuff
[20:14] <qwebirc23602> that would have really tripped me up actually
[20:14] <qwebirc23602> if I had done that
[20:14] <+Mysoft> yeah
[20:14] <+Mysoft> so even if its ugly
[20:14] <+Mysoft> if you want to avoid such stuff
[20:14] <+Mysoft> you can do
[20:14] <qwebirc23602> yeah
[20:14] <+Mysoft> #define MyMacro() print "Hello": print "World"
[20:14] <qwebirc23602> and thatll work?
[20:14] <+Mysoft> yes
[20:14] <qwebirc23602> with if(false) then
[20:14] <+Mysoft> it wont print anything
[20:14] <qwebirc23602> wow ok
[20:15] <+Mysoft> yes as i said
[20:15] <+Mysoft> macros are REALLY text replacement
[20:15] <+Mysoft> so
[20:15] <qwebirc23602> what if I did this
[20:15] <qwebirc23602> https://pastebin.com/wz8i9Cs1
[20:15] <+Mysoft> there's a ENTER after the print
[20:15] <+Mysoft> it will paste that
[20:15] <+Mysoft> in C...
[20:15] <+Mysoft> you would not have such problem
[20:15] <+Mysoft> because C uses ;
[20:15] <+Mysoft> for line end
[20:15] <qwebirc23602> true
[20:15] <+Mysoft> but
[20:15] <+Mysoft> only if you do
[20:16] <+Mysoft> if 0 { MyMacro() }
[20:16] <+Mysoft> if you do
[20:16] <+Mysoft> if 0 MyMacro()
[20:16] <+Mysoft> you are subject to the same thing :P
[20:16] <+Mysoft> actually C requires parenthesis
[20:16] <qwebirc23602> ?
[20:16] <+Mysoft> so
[20:16] <qwebirc23602> { }?
[20:16] <+Mysoft> yes
[20:16] <+Mysoft> in C
[20:16] <+Mysoft> :)
[20:16] <+Mysoft> i never use if's without { }
[20:16] <qwebirc23602> oh
[20:16] <qwebirc23602> in C
[20:16] <+Mysoft> yes
[20:16] <qwebirc23602> I thought you meant FB for a moment
[20:16] <+Mysoft> i just said that in C
[20:16] <qwebirc23602> i missed
[20:16] <qwebirc23602> \o/
[20:16] <+Mysoft> you wouldnt have problems with the multiline macro
[20:17] <+Mysoft> ironically
[20:17] <+Mysoft> C does not have
[20:17] <+Mysoft> a multiline macro
[20:17] <+Mysoft> xD
[20:17] <qwebirc23602> Okay
[20:17] <+Mysoft> but actually
[20:17] <qwebirc23602> https://pastebin.com/wz8i9Cs1
[20:17] <+Mysoft> let me try something that i never did before
[20:18] <qwebirc23602> :_ works
[20:18] <qwebirc23602> what are you trying
[20:19] <+Mysoft> #define MyMacro() _
[20:19] <+Mysoft>   print "Hello"  :_
[20:19] <+Mysoft>   print "World"
[20:19] <+Mysoft> '
[20:19] <+Mysoft> if 0 then MyMacro()
[20:19] <+Mysoft> sleep
[20:19] <+Mysoft> :P
[20:19] <+Mysoft> thats what i tried
[20:19] <qwebirc23602> I just tried that
[20:19] <qwebirc23602> yeah
[20:19] <qwebirc23602> its neat
[20:19] <+Mysoft> indeed we did tried the same thing
[20:19] <+Mysoft> xD
[20:19] <+Mysoft> its a bit ugly
[20:19] <+Mysoft> but probabily less ugly
[20:19] <+Mysoft> then the huge line
[20:19] <+Mysoft> even on the macro
[20:19] <+Mysoft> xD
[20:19] <qwebirc23602> its less ugly than one large line
[20:20] <+Mysoft> so yeah
[20:20] <qwebirc23602> type Pnt
[20:20] <qwebirc23602>     as integer x
[20:20] <qwebirc23602>     as integer y
[20:20] <qwebirc23602> end type
[20:20] <qwebirc23602> dim as Pnt p = type<Pnt>(5,2)
[20:20] <qwebirc23602> print p.x
[20:20] <qwebirc23602> print p.y
[20:20] <qwebirc23602> sleep()
[20:20] <qwebirc23602> is this acceptable
[20:20] <+Mysoft> yes and no
[20:20] <qwebirc23602> why and why
[20:20] <+Mysoft> you would either do
[20:20] <+Mysoft> var p = type<Pnt>(5,2)
[20:20] <+Mysoft> or...
[20:21] <qwebirc23602> but why would I use var
[20:21] <+Mysoft> dim as Pnt p = (5,2)
[20:21] <+Mysoft> ---
[20:21] <qwebirc23602> why var!?
[20:21] <qwebirc23602> I hate var
[20:21] <+Mysoft> i just said
[20:21] <+Mysoft> that they are two ways of doing it
[20:21] <+Mysoft> :P
[20:21] <qwebirc23602> but I just did it in a way that used both your ways
[20:21] <+Mysoft> yes
[20:21] <qwebirc23602> so third way?
[20:21] <+Mysoft> and it becomes ambiguous
[20:21] <qwebirc23602> lol why would I need to use var
[20:21] <qwebirc23602> I know its a Pnt
[20:22] <+Mysoft> so
[20:22] <+Mysoft> then
[20:22] <+Mysoft> dim as Pnt p = (5,2)
[20:22] <+Mysoft> no need to the type<pnt> AGAIN
[20:22] <qwebirc23602> I see
[20:22] <+Mysoft> since as you said
[20:22] <+Mysoft> you already know you its a Pnt :)
[20:22] <qwebirc23602> I added a third variable
[20:22] <qwebirc23602> which is a string
[20:22] <qwebirc23602> dim as Pnt p = (5,2,"ok")
[20:22] <qwebirc23602> this doesnt work now
[20:23] <qwebirc23602> as zstring ptr ok
[20:23] <qwebirc23602> dim as Pnt p = (5,2,@"ok")
[20:23] <qwebirc23602> print *p.ok
[20:23] <qwebirc23602> that works
[20:23] <+Mysoft> yeah
[20:23] <+Mysoft> zstring*x
[20:23] <+Mysoft> would also work
[20:24] <qwebirc23602> *x ?
[20:24] <qwebirc23602> whats the x for
[20:24] <qwebirc23602> length?
[20:24] <+Mysoft> yes
[20:24] <qwebirc23602> dim as Pnt p = (5,2,@"ok")
[20:24] <qwebirc23602> should the ok be null terminated
[20:24] <+Mysoft> type Pnt
[20:24] <+Mysoft>   x as integer
[20:24] <+Mysoft>   y as integer
[20:24] <+Mysoft>   z as zstring*8
[20:24] <+Mysoft> end type
[20:24] <qwebirc23602> dim as Pnt p = (5,2,@!"ok\0")
[20:24] <+Mysoft> (5,2,"ok")
[20:24] <+Mysoft> the \0 is redundant
[20:24] <+Mysoft> its already zero terminated
[20:24] <qwebirc23602> FB takes care of null terminators already?
[20:24] <+Mysoft> yes
[20:24] <qwebirc23602> ok
[20:25] <+Mysoft> also
[20:25] <+Mysoft> the "ok"
[20:25] <+Mysoft> suprised me...
[20:25] <+Mysoft> its probabily a freebasic bug
[20:25] <+Mysoft> it should accept that
[20:25] <qwebirc23602> why
[20:25] <+Mysoft> because its a local
[20:25] <+Mysoft> for example
[20:25] <+Mysoft> dim shared as string = "Hello World"
[20:25] <+Mysoft> is not accepted by freebasic
[20:25] <qwebirc23602> yeah I recall
[20:25] <+Mysoft> because "string" is a dynamic datatype
[20:25] <+Mysoft> with a header
[20:25] <+Mysoft> just like a dynamic array
[20:25] <+Mysoft> so you can't have that initialized
[20:26] <+Mysoft> and even that freebasic could store
[20:26] <+Mysoft> the string descriptor
[20:26] <qwebirc23602> *p.ok = "hello"
[20:26] <qwebirc23602> print *p.ok
[20:26] <+Mysoft> on the .data
[20:26] <qwebirc23602> I just overwrote my "ok"
[20:26] <qwebirc23602> do I need to delete[] it?
[20:26] <qwebirc23602> or clean it up
[20:26] <qwebirc23602> before overwriting it?
[20:26] <+Mysoft> ok is a string?
[20:26] <+Mysoft> of zstring?
[20:26] <qwebirc23602> zstring ptr
[20:27] <qwebirc23602> https://pastebin.com/kGa1svkm
[20:27] <+Mysoft> ok
[20:27] <+Mysoft> then its fine
[20:27] <qwebirc23602> it cleans up automatically?
[20:27] <+Mysoft> well
[20:27] <+Mysoft> it never cleans actually
[20:27] <+Mysoft> but thats fine
[20:27] <qwebirc23602> so I need to clean it?
[20:27] <+Mysoft> because they are constants
[20:27] <qwebirc23602> oh uh
[20:27] <+Mysoft> you can't clean constants
[20:27] <qwebirc23602> ah
[20:27] <qwebirc23602> trye
[20:27] <qwebirc23602> true
[20:27] <+Mysoft> but if it was a string
[20:27] <+Mysoft> generated with allocate
[20:27] <+Mysoft> or whatever
[20:28] <+Mysoft> then you would leak that pointer
[20:28] <+Mysoft> if you just change it
[20:28] <qwebirc23602> so like
[20:28] <qwebirc23602> if I asked for someone's username
[20:28] <qwebirc23602> for a login application
[20:28] <qwebirc23602> the user would generate the data
[20:28] <qwebirc23602> and its not a constant anymore
[20:28] <qwebirc23602> so I need to handle cleaning up
[20:28] <qwebirc23602> that data right
[20:28] <+Mysoft> yeah
[20:28] <qwebirc23602> got it
[20:28] <+Mysoft> but you will do that naturally
[20:28] <+Mysoft> because the "method you use to input"
[20:28] <+Mysoft> would use a temporary buffer
[20:29] <+Mysoft> so you wont just set the buffer
[20:29] <+Mysoft> on the structure
[20:29] <+Mysoft> you would need to clone the string
[20:29] <+Mysoft> before saving on the struct
[20:29] <+Mysoft> OR
[20:29] <+Mysoft> you would reserve the storage space on the struct
[20:29] <+Mysoft> with zstring*x
[20:29] <qwebirc23602> got it
[20:29] <+Mysoft> then just setting would copy the zstring to the struct
[20:29] <+Mysoft> instead of just having a pointer for it
[20:29] <+Mysoft> and for STRING
[20:30] <qwebirc23602> as zstring*5 ok
[20:30] <+Mysoft> then the thing is handled by freebasic
[20:30] <qwebirc23602> this still stores a null terminator huh
[20:30] <qwebirc23602> even though I told it 5 bytes
[20:30] <+Mysoft> yeah
[20:30] <qwebirc23602> ok
[20:30] <+Mysoft> BUT
[20:30] <qwebirc23602> i tried to print "Hello"
[20:30] <qwebirc23602> it printed "Hell"
[20:30] <+Mysoft> freebasic knows its 5 bytes
[20:30] <+Mysoft> (the maximum size)
[20:30] <+Mysoft> so if you have
[20:30] <+Mysoft> dim as string*5 zTemp
[20:30] <+Mysoft> zTemp = "Hello"
[20:30] <+Mysoft> print zTemp
[20:31] <qwebirc23602> 'Hell'
[20:31] <+Mysoft> no
[20:31] <+Mysoft> you actually get Hello
[20:31] <qwebirc23602> o ok
[20:31] <+Mysoft> because zstring*5
[20:32] <+Mysoft> is actually 6 bytes
[20:32] <+Mysoft> you can see it with
[20:32] <+Mysoft> [21:30] <Mysoft> dim as string*5 zTemp
[20:32] <+Mysoft> print sizeof(zTemp)
[20:32] <+Mysoft> but then yes
[20:32] <+Mysoft> if you had
[20:32] <+Mysoft> zstring*4
[20:32] <+Mysoft> and you did
[20:32] <+Mysoft> zTemp = "Hello"
[20:32] <qwebirc23602> why is string*x and zstring*x different
[20:32] <+Mysoft> then you would get Hell
[20:32] <+Mysoft> ok
[20:32] <+Mysoft> string*x is a leftover from qbasic
[20:32] <+Mysoft> it should be avoided
[20:33] <qwebirc23602> got it
[20:33] <+Mysoft> it can be used... but its usefulness
[20:33] <+Mysoft> is limited
[20:33] <+Mysoft> most people that use it
[20:33] <+Mysoft> were because they used it on qbasic
[20:33] <+Mysoft> and on qbasic
[20:33] <+Mysoft> string*1
[20:33] <+Mysoft> was actually a single byte
[20:33] <+Mysoft> while on freebasic
[20:33] <+Mysoft> its 2 types...
[20:33] <+Mysoft> *2 bytes
[20:33] <+Mysoft> just like zstring*x
[20:33] <+Mysoft> but...
[20:33] <+Mysoft> string*n
[20:34] <+Mysoft> have a side effect
[20:34] <+Mysoft> well HAD a side effect
[20:34] <+Mysoft> on QBASIC...
[20:34] <+Mysoft> string*n was a FIXED LENGTH STRING
[20:34] <+Mysoft> period :P
[20:34] <+Mysoft> so
[20:34] <+Mysoft> if you had
[20:34] <+Mysoft> dim s as string*8
[20:34] <+Mysoft> and you did
[20:34] <+Mysoft> s = "Hello"
[20:35] <+Mysoft> print "["+s+"]"
[20:35] <+Mysoft> you would see
[20:35] <+Mysoft> [Hello___]
[20:35] <+Mysoft> where the _ are spaces :)
[20:35] <+Mysoft> freebasic changed that...
[20:35] <+Mysoft> so all in all
[20:35] <+Mysoft> string*x does not have any benefit
[20:35] <qwebirc23602> interesting
[20:35] <+Mysoft> over zstring*x
[20:36] <qwebirc23602> is this acceptable?
[20:36] <qwebirc23602> #MACRO createPnt(_x,_y) type<Pnt>((_x),(_y)) #ENDMACRO
[20:36] <qwebirc23602> just curious
[20:36] <qwebirc23602> I dont intend on using it
[20:36] <qwebirc23602> am just wondering if thats okay
[20:36] <+Mysoft> well
[20:36] <+Mysoft> it is... i guess
[20:36] <+Mysoft> BUT
[20:36] <+Mysoft> i just say it is because remember
[20:36] <+Mysoft> i keep macro definitions
[20:36] <+Mysoft> close to where i use them
[20:36] <+Mysoft> :P
[20:36] <qwebirc23602> right
[20:37] <+Mysoft> in your case
[20:37] <+Mysoft> you would use that
[20:37] <+Mysoft> with it defined elsewhere
[20:37] <+Mysoft> so it ends on the "meh" side
[20:37] <+Mysoft> :P
[20:37] <+Mysoft> as you need to learn a different language
[20:37] <+Mysoft> to be able to understand your code
[20:37] <+Mysoft> heheh
[20:37] <+Mysoft> so i'm little biased against that
[20:37] <+Mysoft> for pratical purposes
[20:38] <+Mysoft> but i'm also not harsh on people that use that
[20:38] <+Mysoft> but keep in mind
[20:38] <+Mysoft> overusage of macros...
[20:38] <+Mysoft> can lead to some problems of OOP
[20:38] <+Mysoft> where you may not see optimizations
[20:38] <+Mysoft> because you tuned the code
[20:38] <+Mysoft> to use the macros
[20:38] <+Mysoft> instead of write stuff in a different way
[20:38] <+Mysoft> :P
[20:38] <+Mysoft> when the opportunity comes
[20:38] <+Mysoft> so... if you get addicted to that
[20:38] <+Mysoft> it may be bad
[20:41] <qwebirc23602> stance on using overloads?
[20:41] <qwebirc23602> I want a function `toString(???)`
[20:41] <qwebirc23602> which I can pass any of my custom structs
[20:41] <qwebirc23602> and itll output information in the format of a string
[20:42] <+Mysoft> nooooooooooo
[20:42] <+Mysoft> :P
[20:42] <qwebirc23602> no overloads? :(
[20:42] <+Mysoft> anyway the way you are doing its fine
[20:42] <+Mysoft> :P
[20:42] <qwebirc23602> https://pastebin.com/68qKUqZH
[20:42] <+Mysoft> my noooo was because the chilly nilly
[20:42] <qwebirc23602> should i use macros for this too
[20:42] <+Mysoft> of reading javascript
[20:42] <+Mysoft> :P
[20:43] <+Mysoft> you even used
[20:43] <+Mysoft> toString()
[20:43] <+Mysoft> like js
[20:43] <+Mysoft> :P
[20:43] <qwebirc23602> oh?
[20:43] <qwebirc23602> how so?
[20:43] <qwebirc23602> isnt toString a method
[20:43] <qwebirc23602> of datatypes
[20:43] <+Mysoft> exactly
[20:43] <+Mysoft> its a javascript (maybe java thing)
[20:43] <+Mysoft> its an OOP thing
[20:43] <+Mysoft> you are not using it as OOP
[20:43] <+Mysoft> but
[20:43] <+Mysoft> you even use the name
[20:43] <+Mysoft> with the js casing
[20:43] <+Mysoft> lowerCamelCase
[20:43] <+Mysoft> :P
[20:44] <+Mysoft> so it gave me chills
[20:44] <+Mysoft> xD
[20:44] <+Mysoft> i.e.
[20:44] <+Mysoft> ToString vs toString
[20:44] <+Mysoft> :P
[20:44] <qwebirc23602> I dont think how I named it matters
[20:44] <+Mysoft> i know
[20:44] <+Mysoft> i just said
[20:44] <qwebirc23602> what matters is efficiency
[20:44] <+Mysoft> that reading the toString
[20:44] <qwebirc23602> Yeah
[20:44] <+Mysoft> gave me chills
[20:44] <qwebirc23602> Alright
[20:44] <+Mysoft> because i did remember of JS
[20:44] <+Mysoft> xD
[20:44] <qwebirc23602> its in .Net too
[20:44] <qwebirc23602> and Java
[20:45] <+Mysoft> thanks for the extra nightmare
[20:45] <qwebirc23602> I think even MySQL OOP version has toString too
[20:45] <qwebirc23602> it's a valid name
[20:45] <qwebirc23602> it turns thing into strings...
[20:45] <+Mysoft> yeah anyway
[20:45] <+Mysoft> good thing i'm very far from such crap
[20:45] <+Mysoft> but ok
[20:45] <+Mysoft> overload
[20:45] <+Mysoft> is kinda fine the way you did
[20:45] <qwebirc23602> ok
[20:45] <+Mysoft> i would just ask
[20:45] <+Mysoft> to not export such thing in a dll
[20:45] <qwebirc23602> I didnt intend to
[20:45] <+Mysoft> because if you do
[20:45] <qwebirc23602> why would i
[20:45] <+Mysoft> you will see it will be named
[20:46] <+Mysoft> ToString@#U&*(@JUOISJCNKLSADJIKO@#( *($QWOIHDASIOH@ )
[20:46] <+Mysoft> :P
[20:46] <qwebirc23602> I believe ive had this issue before
[20:46] <+Mysoft> because of the name mangling :P
[20:46] <+Mysoft> since overloads add the type that is being overloaded
[20:46] <+Mysoft> as part of the name
[20:46] <qwebirc23602> Righto
[20:46] <+Mysoft> and its something that i find to be
[20:46] <+Mysoft> a terrible practice among C++ coders
[20:46] <+Mysoft> to export things with name mangling
[20:46] <qwebirc23602> is concat'ing like this ok in FB?
[20:46] <qwebirc23602> "(" & p->x & "," & p->y & ")"
[20:47] <+Mysoft> yes
[20:47] <+Mysoft> but
[20:47] <+Mysoft> imo you should use sprintf
[20:47] <qwebirc23602> I use this function often
[20:47] <qwebirc23602> Yeah I made a subroutine called
[20:47] <qwebirc23602> echo
[20:47] <qwebirc23602> which uses printf
[20:47] <+Mysoft> because
[20:47] <qwebirc23602> because it goes to the console
[20:47] <qwebirc23602> instead of the graphics
[20:47] <qwebirc23602> which I like
[20:47] <qwebirc23602> for debugging
[20:47] <+Mysoft> sprintf( "(%i,%i)", p->x , p->y )
[20:47] <+Mysoft> is much more sane :P
[20:47] <qwebirc23602> oh
[20:47] <+Mysoft> but yes
[20:48] <qwebirc23602> thatll return a string
[20:48] <qwebirc23602> ?
[20:48] <+Mysoft> well
[20:48] <qwebirc23602> the main thing is that it has to return a string
[20:48] <+Mysoft> sprintf( zstring , "(%i,%i)", p->x , p->y )
[20:48] <qwebirc23602> hm
[20:48] <+Mysoft> it will FILL that on a string
[20:48] <+Mysoft> as its a C thing
[20:48] <qwebirc23602> itll add a null terminator?
[20:48] <+Mysoft> it wont work with strings
[20:48] <+Mysoft> yes
[20:48] <+Mysoft> and it returns the number of bytes
[20:48] <+Mysoft> generated
[20:48] <+Mysoft> so you know the resulting length
[20:49] <+Mysoft> its very useful for appending :)
[20:49] <+Mysoft> but its the C style
[20:49] <+Mysoft> so no "strings" there
[20:49] <+Mysoft> actually i avoid returning strings on freebasic
[20:49] <+Mysoft> because i dont like the allocation
[20:49] <+Mysoft> that happens there
[20:49] <+Mysoft> i normally would do this
[20:50] <qwebirc23602> how do I convert a zstring to string
[20:50] <qwebirc23602> zstring ptr*
[20:50] <+Mysoft> function GetName( iIndexOrWhatever as integer , sOutputString as string ) as integer
[20:50] <+Mysoft> i would normally do this
[20:50] <+Mysoft> and so it would return the string
[20:50] <+Mysoft> trough the parameter passed to it
[20:50] <+Mysoft> (as strings are passed byref)
[20:50] <+Mysoft> so the function would set the sOutputString directly
[20:51] <+Mysoft> instead of making a new string
[20:51] <+Mysoft> with the result
[20:51] <+Mysoft> that has the allocate cost
[20:51] <+Mysoft> *zstringptr
[20:51] <+Mysoft> will turn it into a string
[20:52] <qwebirc23602> https://pastebin.com/1nk9gBnm
[20:52] <qwebirc23602> im having issues
[20:53] <qwebirc23602> dim as pnt p = (5,2)
[20:53] <qwebirc23602> **
[20:53] <qwebirc23602> Force of habit
[20:54] <+Mysoft> well
[20:54] <+Mysoft> structs are already passed byref
[20:54] <+Mysoft> so the @
[20:54] <+Mysoft> is not required
[20:54] <+Mysoft> neither is the "pnt ptr"
[20:54] <+Mysoft> but on the other hand
[20:54] <+Mysoft> if you are using "new"
[20:54] <+Mysoft> to allocate the quads
[20:54] <+Mysoft> then you already have a pointer
[20:54] <+Mysoft> and if it was
[20:54] <+Mysoft> just as
[20:55] <+Mysoft> pnt
[20:55] <+Mysoft> then you will need to pass *p
[20:55] <+Mysoft> so... whatever :P
[20:55] <+Mysoft> both ways have theirs pro/cons
[20:56] <qwebirc23602> I do use new
[20:56] <qwebirc23602> Id like to keep them as pointers
[20:56] <+Mysoft> yeah
[20:56] <+Mysoft> using pointers
[20:56] <+Mysoft> for such small structures
[20:56] <+Mysoft> is a huge overhead
[20:56] <+Mysoft> you know
[20:56] <qwebirc23602> well I keep them in a list
[20:56] <+Mysoft> each of these new
[20:56] == Agamemnus [~Agamemnus@pool-108-26-248-68.bstnma.fios.verizon.net] has joined ##freebasic
[20:56] == mode/##freebasic [+v Agamemnus] by ChanServ
[20:56] <+Mysoft> take 16 bytes of memory?
[20:56] <+Mysoft> for the "allocation" header
[20:57] <+Mysoft> plus the 4 bytes for the pointer itself
[20:57] <+Mysoft> (double that on 64bit)
[20:57] <qwebirc23602> interesting
[20:57] <+Mysoft> so having them on an array
[20:57] <+Mysoft> and just passing the index around
[20:57] <+Mysoft> is potentially better
[20:57] <qwebirc23602> so are you saying
[20:57] <qwebirc23602> fill an array of just empty variables
[20:58] <qwebirc23602> and keep track of what has been initialized and what hasnt
[20:58] <+Mysoft> maybe
[20:58] <+Mysoft> but
[20:58] <+Mysoft> in your model
[20:58] <+Mysoft> you never delete
[20:58] <+Mysoft> so...
[20:58] <+Mysoft> you know what is initialized
[20:58] <qwebirc23602> What do I not delete?
[20:58] <+Mysoft> just by having a COUNT
[20:58] <+Mysoft> the quads...
[20:58] <qwebirc23602> when a troop dies he is deleted
[20:58] <+Mysoft> ok
[20:58] <qwebirc23602> or I just
[20:58] <qwebirc23602> ignore his index
[20:59] <qwebirc23602> but
[20:59] <qwebirc23602> i do want to recycle
[20:59] <+Mysoft> yeah
[20:59] <qwebirc23602> spaces
[20:59] <+Mysoft> so having a bit or byte
[20:59] <+Mysoft> with flags for the troop
[20:59] <+Mysoft> one of them being if its there or not
[20:59] <+Mysoft> or...
[20:59] <+Mysoft> reusing its X/Y
[20:59] <+Mysoft> like
[20:59] <qwebirc23602> a union?
[20:59] <+Mysoft> X = 0
[20:59] <+Mysoft> meaning its not there
[20:59] <+Mysoft> could be also used
[20:59] <qwebirc23602> right
[20:59] <+Mysoft> altough X being 0
[21:00] <+Mysoft> could be a valid position
[21:00] <qwebirc23602> theyre integers
[21:00] <qwebirc23602> so -1
[21:00] <+Mysoft> yeah either that or an extra bit
[21:00] <+Mysoft> since you will probabily have a bitfield
[21:00] <+Mysoft> for the states
[21:00] <qwebirc23602> yeah
[21:00] <qwebirc23602> I will
[21:00] <+Mysoft> so having just one extra bit there is fine
[21:00] <+Mysoft> and gen gcc optimizes that very well
[21:01] <+Mysoft> (single bit checks)
[21:01] <+Mysoft> :)
[21:01] <+Mysoft> but yeah
[21:01] <+Mysoft> having a circular array
[21:01] <+Mysoft> with max number of units
[21:01] <+Mysoft> could be useful to recycle them
[21:01] <+Mysoft> and can be potentially faster
[21:02] <+Mysoft> than using new/delete
[21:02] <+Mysoft> specially since that could be a static global
[21:02] <+Mysoft> but if the contrast is too big
[21:03] <+Mysoft> that having a static global would waste space
[21:03] <+Mysoft> then a dynamic allocated arrays would be my second guess
[21:03] <+Mysoft> but if the goal is to speed up
[21:03] <+Mysoft> i would have one static array per CLASS
[21:03] <+Mysoft> CLASS = type of unit
[21:04] <+Mysoft> so one array for all the pawns
[21:04] <+Mysoft> one array for all the bishops
[21:04] <+Mysoft> one array for all the knights
[21:04] <+Mysoft> and so on
[21:04] <+Mysoft> so that way you may end with smaller arrays
[21:05] <+Mysoft> and faster to search (or not)
[21:05] <+Mysoft> it depends on too much thing
[21:05] <+Mysoft> so... whatever :)
[21:05] <+Mysoft> just saying... that the "new/delete" is the generic way
[21:05] <+Mysoft> but you for sure always have a targeted way
[21:05] <+Mysoft> that can potentially speed up something
[21:06] <+Mysoft> even a double linked list on the array
[21:07] <+Mysoft> which would incur two extra elements
[21:07] <+Mysoft> for previous/next
[21:07] <+Mysoft> that way its faster to locate "holes"
[21:07] <+Mysoft> but really
[21:07] <+Mysoft> imo the best way to recycle
[21:07] <+Mysoft> is swap :)
[21:07] <+Mysoft> for example...
[21:08] <+Mysoft> when you ADD an unit... you add it to the last position
[21:08] <+Mysoft> and when you remove
[21:08] <+Mysoft> you put what was on the end of the list
[21:08] <+Mysoft> into the hole you created
[21:08] <+Mysoft> but... that only works
[21:08] <+Mysoft> if you dont have references to the units elsewhere
[21:08] <+Mysoft> as you would need to update all the references to it
[21:08] <+Mysoft> to keep this list without holes
[21:09] <+Mysoft> but...
[21:09] <+Mysoft> since add/new may not be a bottleneck
[21:10] <+Mysoft> you have to actually see what is your bottleneck before deciding
[21:10] <+Mysoft> what you do most...
[21:10] <+Mysoft> you would SEARCH for a unit...
[21:10] <+Mysoft> you would ACCESS it most often
[21:10] <+Mysoft> or you would ADD/REMOVE most often
[21:10] <+Mysoft> so the overhead of "updating" dependencies when a unit is deleted
[21:10] <+Mysoft> may be small enough to make up even for the cost of "delete"
[21:11] <+Mysoft> anyway talked too much xD
[21:21] <qwebirc23602> All good information
[21:31] == Thedarkb-X40 [~beno@51-171-49-156-dynamic.agg3.kny.prp-wtd.eircom.net] has joined ##freebasic
[21:49] == Mysoft [~user@unaffiliated/mysoft]
[21:49] ==  realname : Limp Bizkit User
[21:49] ==  channels : +##freebasic
[21:49] ==  server   : weber.freenode.net [US]
[21:49] ==  account  : Mysoft
[21:49] == End of WHOIS
[21:55] <qwebirc23602> is it ok to use ubyte as my boolean replacement
[21:55] <qwebirc23602> or should i be sticking with integers
[21:55] <qwebirc23602> I have a stopwatch struct
[21:56] <qwebirc23602> Im using a ubyte as a flag to see if its running or not
[21:56] <qwebirc23602> also my rect struct returns a ubyte if it overlaps with another rect
[21:59] <+Mysoft> its ok to use ubyte as boolean
[21:59] <+Mysoft> in fact C uses integer
[21:59] <+Mysoft> but winapi uses BYTE
[21:59] <+Mysoft> (that is ubyte)
[21:59] <qwebirc23602> what do you suggest I use
[21:59] <+Mysoft> well
[21:59] <+Mysoft> maybe you can just use boolean
[21:59] <+Mysoft> but
[21:59] <+Mysoft> #undef boolean
[22:00] <+Mysoft> #define boolean ubyte
[22:00] <+Mysoft> :)
[22:00] <+Mysoft> now you have boolean
[22:00] <+Mysoft> but without requiring fb 1.0.3
[22:00] <+Mysoft> hehe
[22:00] <+Mysoft> i normally recommend to do that
[22:00] <+Mysoft> but ok
[22:00] <+Mysoft> as for the size
[22:00] <+Mysoft> for return of function
[22:00] <+Mysoft> it does not matter
[22:00] <+Mysoft> because the return of functions is returned on EAX
[22:01] <+Mysoft> that is 32bit
[22:01] <+Mysoft> so even if you use a byte
[22:01] <+Mysoft> it will still be on the 32bit register
[22:01] <+Mysoft> however if you will have it on a struct
[22:01] <+Mysoft> and its not a single bit on a bitfield
[22:01] <+Mysoft> then... probabily ubyte would be recommended to save space
[22:01] <+Mysoft> BUT
[22:01] <+Mysoft> this only makes sense if you align the stuff on the struct properly
[22:02] <qwebirc23602> Im looking for speed optimization
[22:02] <qwebirc23602> not memory
[22:02] <qwebirc23602> memory is plenty
[22:02] <+Mysoft> well memory optimization
[22:02] <+Mysoft> also means speed optimization
[22:02] <+Mysoft> in many cases
[22:02] <+Mysoft> because you have less to compute
[22:03] <+Mysoft> so it caches better
[22:03] <+Mysoft> just like the 8bpp vs 16bpp vs 32bpp screen
[22:03] <qwebirc23602> yeah I know but Im just saying
[22:03] <+Mysoft> you have not noticed the speed up
[22:03] <+Mysoft> because you had lot of bottlenecks
[22:03] <qwebirc23602> I guess
[22:03] <+Mysoft> and circle/line you had
[22:03] <+Mysoft> had a bottleneck that made the improvements for it being <bpp moot
[22:03] <+Mysoft> :P
[22:03] <+Mysoft> so anyway
[22:03] <+Mysoft> as i said
[22:03] <+Mysoft> on the struct
[22:03] <+Mysoft> it would be optimal to have it stored as a single bit
[22:04] <+Mysoft> then you get all the benefits of boolean
[22:04] <+Mysoft> but otherwise
[22:04] <+Mysoft> you wont have any speed difference
[22:04] <+Mysoft> on byte vs integer
[22:04] <qwebirc23602> Just in general coding practice tho
[22:04] <qwebirc23602> byte vs integer
[22:04] <+Mysoft> well
[22:04] <+Mysoft> i normally use integer
[22:04] <qwebirc23602> I know things use integer a lot more often
[22:04] <+Mysoft> when returning from functions
[22:05] <qwebirc23602> so it has to cast the byte to integer
[22:05] <+Mysoft> yeah but that cast
[22:05] <+Mysoft> is not really speed changing for example
[22:05] <+Mysoft> integer to integer
[22:05] <+Mysoft> it would use
[22:05] <+Mysoft> mov eax, [MyInteger]
[22:05] <+Mysoft> that takes 1 cycle + memory access
[22:05] <+Mysoft> if it was byte
[22:05] <+Mysoft> it would use
[22:06] <+Mysoft> movzx eax, byte [MyInteger]
[22:06] <+Mysoft> that takes 1 cycle + memory access
[22:06] <+Mysoft> :P
[22:06] <+Mysoft> err
[22:06] <+Mysoft> MyByte
[22:06] <+Mysoft> :)
[22:06] <+Mysoft> and gen gcc would optimize it
[22:06] <+Mysoft> to handle 1bit
[22:06] <+Mysoft> if you keep it just 0 or 1
[22:07] <+Mysoft> so as i said
[22:07] <+Mysoft> for returning values keeping it as integer is fine
[22:07] <+Mysoft> for structures if you have flags use bitfield with just 1 bit
[22:07] <+Mysoft> otherwise use integer or byte
[22:07] <+Mysoft> if its an array that may end wasting space
[22:07] <+Mysoft> you can use byte
[22:08] <+Mysoft> as long you have other stuff that fit on byte's on the structure
[22:08] <+Mysoft> otherwise alignment will make the byte useless :P
[22:21] <qwebirc23602> did you say anything about doing stuff like
[22:21] <qwebirc23602> if(NOT flag) then
[22:21] <qwebirc23602> vs
[22:22] <qwebirc23602> if(flag <> 0)
[22:22] <qwebirc23602> Mysoft
[22:26] <+Mysoft> well
[22:26] <+Mysoft> <>0 is not necessary
[22:26] <+Mysoft> you can just do
[22:26] <+Mysoft> if flag then...
[22:26] <+Mysoft> but maybe you mean
[22:26] <qwebirc23602> but the way I wrote it
[22:26] <+Mysoft> if (NOT flag)
[22:26] <+Mysoft> vs
[22:26] <+Mysoft> if (flag=0)
[22:26] <+Mysoft> :P
[22:26] <qwebirc23602> oh
[22:26] <qwebirc23602> yeah that too
[22:26] <qwebirc23602> haha
[22:26] <+Mysoft> i would say to not use NOT
[22:26] <+Mysoft> :P
[22:27] <+Mysoft> because NOT is bitwise NOT...
[22:27] <qwebirc23602> not not not not
[22:27] <+Mysoft> not logical NOT
[22:27] <+Mysoft> :P
[22:27] <+Mysoft> so
[22:27] <+Mysoft> NOT -1 = 0
[22:27] <+Mysoft> but
[22:27] <+Mysoft> NOT 1 = -2
[22:27] <+Mysoft> and both 1 and -2 are TRUE
[22:27] <+Mysoft> since TRUE is anything but 0
[22:28] <+Mysoft> freebasic "boolean type"
[22:28] <+Mysoft> would make that work
[22:28] <+Mysoft> even with NOT
[22:28] <+Mysoft> but it adds an overhead
[22:28] <+Mysoft> of compare
[22:28] <+Mysoft> everytime you change it
[22:28] <+Mysoft> so
[22:29] <+Mysoft> IsNot(flag)
[22:29] <+Mysoft> :P
[22:29] <+Mysoft> would be wise... to avoid such stuff
[22:29] <+Mysoft> so then you can have the #define
[22:29] <+Mysoft> doing it properly
[22:29] <+Mysoft> but at your control
[22:29] <+Mysoft> #define IsNot( _F ) ((_F)=0)
[22:33] <qwebirc23602> Nice
[22:33] <qwebirc23602> I like these pre-processor things
[22:33] <+Mysoft> so as i said
[22:33] <+Mysoft> having the boolean type in practice is ok
[22:33] <+Mysoft> in theory its ok
[22:33] <qwebirc23602> #define BOOLEAN UBYTE
[22:33] <qwebirc23602> #define TRUE 1
[22:33] <qwebirc23602> #define FALSE 0
[22:33] <qwebirc23602> :)
[22:33] <+Mysoft> yeah
[22:33] <qwebirc23602> #define isFalse( _F ) ((_F)=FALSE)
[22:34] <+Mysoft> in FB true is actually -1
[22:34] <+Mysoft> but anyway
[22:34] <+Mysoft> just please
[22:34] <+Mysoft> never do
[22:34] <+Mysoft> if MyBoolean = TRUE
[22:34] <+Mysoft> :P
[22:34] <qwebirc23602> oh
[22:34] <qwebirc23602> yeah
[22:34] <qwebirc23602> I never do that
[22:34] <qwebirc23602> thats a rookie move
[22:34] <+Mysoft> yeah
[22:34] <+Mysoft> specially since you already have the
[22:34] <+Mysoft> if MyBoolean then
[22:35] <qwebirc23602> yeah that frustrates me when I see other people's code and it has that
[22:35] <+Mysoft> and yes i like the IsNot()
[22:35] <+Mysoft> because its the complement that missing on freebasic
[22:35] <+Mysoft> for example
[22:35] <+Mysoft> and -> andalso
[22:35] <+Mysoft> or -> orelse
[22:35] <+Mysoft> but freebasic does not have the
[22:35] <+Mysoft> not -> IsNot
[22:36] <+Mysoft> they should had added that... not the "boolean" type
[22:36] <+Mysoft> and worse
[22:36] <+Mysoft> they added too late
[22:36] <+Mysoft> on version 1.0.3
[22:36] <qwebirc23602> what does andalso do
[22:36] <qwebirc23602> and orelse
[22:36] <+Mysoft> & = and
[22:36] <+Mysoft> | = or
[22:36] <+Mysoft> && = andalso
[22:36] <+Mysoft> || = orelse
[22:37] <qwebirc23602> ....So ive been using bitwise operations my entire freebasic career too??
[22:37] <qwebirc23602> sheesh
[22:37] <+Mysoft> yes :P
[22:37] <+Mysoft> well
[22:37] <+Mysoft> sometimes using them are faster
[22:37] <+Mysoft> because the || requires logic decisions
[22:37] <+Mysoft> so doing
[22:37] <+Mysoft> if A=0 and B = 0
[22:37] <+Mysoft> is usually faster than
[22:38] <+Mysoft> if A=0 andalso B=0
[22:38] <+Mysoft> altough
[22:38] <+Mysoft> if (A or B)=0 then
[22:38] <+Mysoft> is even faster :P
[22:38] <+Mysoft> but anyway
[22:38] <+Mysoft> HOWEVER if you have
[22:39] <+Mysoft> if CanIProceed andalso ThisOtherSpecificFunctionCall() then ...
[22:39] <+Mysoft> the ThisOtherSpecificFunctionCall() will never be called
[22:39] <+Mysoft> in case CanIProceed is false
[22:39] <+Mysoft> but
[22:39] <+Mysoft> if CanIProceed and ThisOtherSpecificFunctionCall()
[22:40] <+Mysoft> then it would always call
[22:40] <+Mysoft> and get the result
[22:40] <+Mysoft> and bitwise and
[22:40] <+Mysoft> and then check
[22:40] <+Mysoft> also since thats bitwise
[22:40] <+Mysoft> it could have other problems as well
[22:40] <+Mysoft> assume ThisOtherSpecificFunctionCall() returns 0 or 1
[22:40] <+Mysoft> but CanIProceed
[22:40] <+Mysoft> is 0 or 16
[22:41] <+Mysoft> (1 and 16) = 0
[22:41] <+Mysoft> so it would fail when both were "true"
[22:41] <+Mysoft> so... andalso would have fixed that
[22:41] <+Mysoft> or you would explicit do
[22:41] <+Mysoft> if CanIProceed<>0 and FunctionCall()<>0 then ...
[22:41] <+Mysoft> like it was on classic BASIC
[22:41] <+Mysoft> :)
[22:42] <+Mysoft> but yes
[22:42] <+Mysoft> this can save your skin on stuff like
[22:42] <+Mysoft> if MyPointer andalso *MyPointer=10 then ...
[22:43] <+Mysoft> since the pointer will only be referenced in case MyPointer is not null
[22:43] <+Mysoft> and again... AND would cause it to crash hehe
[23:31] <qwebirc23602> Mysoft
[23:31] <qwebirc23602> if youre interested to take a look at my work so far
[23:31] <qwebirc23602> https://share.dmca.gripe/vn6IGbiQ4LkrjPz7.zip
[23:41] <+Mysoft> i see
[23:41] <+Mysoft> the dots you are drawing with pointers now
[23:41] <+Mysoft> or still circles?
[23:50] <qwebirc23602> I havent implemented the global array yet
[23:50] <qwebirc23602> all the dots are stored in the QuadTree at the moment
[23:50] <qwebirc23602> Oh
[23:50] <qwebirc23602> Im still drawing them with circles at the moment
[23:53] <qwebirc23602> 500,000 points rendering at 80ms
[23:54] <qwebirc23602> Mysoft how can I make a proper zoom algorithm
[23:54] <qwebirc23602> I dont like how it gets slower for me to zoom in as I get closer
[23:54] <qwebirc23602> and as I zoom out farther it gets faster
[23:54] <qwebirc23602> a nice constant speed would be great
[23:55] <qwebirc23602> probably should be adding zoom instead of multiplying